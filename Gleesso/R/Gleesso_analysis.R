#' @title extract_community_abundance_table
#' @description
#' function to handily extract only the abondance of community by
#' samples tables (and remove the extra information from the table like community composition)
#' @param Community_table : a table of community composition generated by the Compute_community_abondance function
#' @export
extract_community_abundance_table <- function(Community_table)
{
  cn = names(Community_table)
  Community_abund = Community_table[!rownames(Community_table) %in% c('Community_composition','Community_pval','community_index'),]
  rnt = row.names(Community_abund)
  Community_abund = as.data.frame(lapply(Community_abund, as.numeric))
  rownames(Community_abund) = rnt
  names(Community_abund) = cn
  return(Community_abund)
}

#' @title community_contrast_dashboard
#' @description
#' create a graphic with a facet by community and a boxplot by modality of the contrast vector
#' @param community_table : a table of community composition generated by the Compute_community_abondance function
#' @param contrast_name : how the contrast column should be named
#' @param contrast_vector : the contrast vector
#' @export
community_contrast_dashboard <- function(community_table,
                                contrast_name,
                                contrast_vector,
                                        nrow = 4,
                                levels_class = c('low', 'high'), color_vect = NULL, offset= 10^-8)
{
    abund_com = extract_community_abundance_table(community_table)

    # creating a column with the vector of factor

    #abund_com[contrast_name] = 0
    #abund_com[,contrast_name] = contrast_vector

   pval_vec <- contrast_by_community_p_val(contrast_vector, abund_com)

   names(pval_vec) = names(community_table)

    label_with_pval <- function(var)
    {
      #  print(class(paste(var,'p-val=', signif(pval_vec[var],2))))
        return(paste(substr(var, 1, 20) ,'p-val=', signif(pval_vec[var],2)))
    }
    abund_com = abund_com[,order(pval_vec)]
    abund_com[contrast_name] = contrast_vector
    abund_mh_long <- melt(abund_com, id.vars=contrast_name)
    abund_mh_long$value = as.numeric(abund_mh_long$value)

    options(repr.plot.width=10, repr.plot.height=12)
    p =ggplot(abund_mh_long, aes(x=as.factor(get(contrast_name)), y= log10(value+offset)))

    if(is.null(color_vect))
    {
        p = p +geom_violin(fill='cornflowerblue')  +geom_boxplot(fill="gray12",notch=TRUE, width=0.6)+ theme(legend.position="none",strip.text.x = element_text(size = 7))  + xlab('') + ylab('log10(abundance + 1e-8)') #+ geom_jitter(width=0.5,alpha=0.4,shape=1,color="blue")
    }
    else
    {
        p = p + geom_violin(aes(fill = get(contrast_name)))  +geom_boxplot(fill="gray12",notch=TRUE, width=0.6)+ theme(legend.position="none",strip.text.x = element_text(size = 7))  + xlab('') + ylab('log10(abundance + 1e-8)') #+ geom_jitter(width=0.5,alpha=0.4,shape=1,color="blue")
    }

    p = p + facet_wrap(~ variable, scales='free',labeller=labeller(variable=label_with_pval),nrow=nrow)
    print(p)
    return(pval_vec)
}

contrast_by_community_p_val <-function(contrast_vector, abund_com)
{

  # computing most contrasted communities
# rank test if the contrast contain only two modality
if(length(unique(contrast_vector)) == 2 )
    {
        rank_pval <- function(x, contrast_vect )
        {
            x= as.numeric(x)
            class1 = unique(contrast_vect)[1]
            return(wilcox.test(x[contrast_vect == class1] , x[contrast_vect != class1])$p.value)
        }
     pval_vec = sapply(abund_com, rank_pval, contrast_vect = contrast_vector)
    }
else{
    # kruskal test if the contrast contain more than two modality
    if(length(unique(contrast_vector)) > 2)
    {
        pval_vec = c()
        for(i in lapply(abund_com, kruskal.test, g = contrast_vector))
            {
            pval_vec = c(pval_vec, i$p.value)
        }

        }
    else{
        stop("The contrast vector contains only one modality")
        }
    }
return(pval_vec)
}

#' @title community_taxa_abundance
#' @description
#' This function generate latex table to help the interpretation of community:
#'  * Table of the list of species in each community
#'  * Compute the proportion of taxa for each community and create:
#'      * create a table listing taxa and their proportion
#'      * create a barplot of taxa proportion
#' @param Nodes graph table
#' @param MGS_by_taxo_species : Nodes abundance
#' @param file_output : file prefix for relative abundance figure
#' @export
community_taxa_abundance <- function(
                                                       Nodes,
                                                       MGS_by_taxo_species,
                                                       file_output,
                                                       community_kind="walktrap_community",
                                                       width_graph = 14,
                                                       height_graph= 5,
                                                       community_levels=NULL,
                                                       prevalence_level = 0.01) # to reorder community in the plot
{
    sum_abund_by_sp = apply(MGS_by_taxo_species, 1, sum)
    Nodes['sum_abundance'] = sum_abund_by_sp[rownames(Nodes)]
    table_list <- list()
    for(group in c("genus", "family", "phylum", "class", "order"))
    {
        Nodes[is.na(Nodes[, group]), group ] = "x Unknown"

        p_tab = prop.table(xtabs(Nodes$sum_abundance ~ as.character(Nodes[,community_kind]) + unlist(Nodes[,group]), Nodes, na.action=na.exclude), margin=1)
        prevalent_genus = which(apply(p_tab > as.numeric(prevalence_level),2,any))
        # if there is more than one rare genera some their abundance in one column
      Ngroup = length(unique(Nodes[, group ]))
      Nprevalent = length(prevalent_genus)

      if((Ngroup - Nprevalent) >1)
      {
      trim_tab = cbind(p_tab[, prevalent_genus],
                       others = apply(p_tab[,  -prevalent_genus], 1, sum))
      }else
      {
          trim_tab = cbind(p_tab[, prevalent_genus], others = p_tab[,  -prevalent_genus])
      }

      long_p_tab =melt(trim_tab)
      names(long_p_tab)[1:2] = c("community",group)

        nameo = paste(file_output, group, "relative_barplot.png", sep="_")

        png(width = width_graph,  height =height_graph, file = nameo, units= "in", res = 200)
        nclass = dim(trim_tab)[2]
        pal_col <- colorRampPalette(brewer.pal(9, "Set1"))(nclass)
        long_p_tab$community = factor(long_p_tab$community, levels = sort(unique(long_p_tab$community), decreasing=TRUE))

        p = ggplot(long_p_tab, aes(x= community,fill=get(group), weight=value))
        p= p + geom_bar() + scale_fill_manual(values=pal_col) + theme(legend.text=element_text(size=8))#position="fill")
        p = p + labs(x = "community", y = "", fill= group)  +theme(axis.text.y = element_text(hjust  = 1,angle = 0, size=12)) + coord_flip()
        print(p)
        dev.off()
        taxa_ordered_list(p_tab)
        table_list[[group]] <-  p_tab
    }
return(table_list)
}

#' @title draw community total abundance treshold
#' @description
#' A function to draw a barplot of the mean abundance of community accross samples
#' @param abund : table of community abundance accross samples
#' @export
draw_community_total_abundance <- function(abund,color_map = NULL)
{
    D = colMeans(apply(abund,2,  as.numeric))
    D = data.frame(D)

    D['community'] = rownames(D)
    D$community = factor(D$community, levels = sort(as.character(unique(D$community)), decreasing=TRUE))

    if(is.null(color_map))
    {
    p = ggplot(D, aes(x= community, weight=D))+ geom_bar() + coord_flip() + ylab('mean abundance')
    } else{
    p = ggplot(D, aes(x= community, weight=D, fill=community))+ scale_fill_manual(values=color_map)+ geom_bar() + coord_flip() + ylab('mean abundance')
  }

return(p)
}

#' @title draw_community_total_species_count
#' @description
#' draw a barplot of the number of species by community
#'
#' @param community_table : Community table with the species composition line
#' @export
draw_community_total_species_count <- function(community_table,color_map = NULL)
{
  species_list = sapply(community_table[1,], strsplit, '-')
  sp_count = as.data.frame(sapply(species_list, length))

  names(sp_count)[1] = "count"
  sp_count['community_name'] = row.names(sp_count)
  sp_count$community_name = factor(sp_count$community_name, levels = sort(as.character(unique(sp_count$community_name)), decreasing=TRUE))
  if(is.null(color_map))
  {
  p = ggplot(sp_count, aes(x = community_name, weights= count)) + geom_bar() + coord_flip()
    }
    else
    {
    p = ggplot(sp_count, aes(x= community_name, weight=count, fill=community_name))
    p = p + scale_fill_manual(values=color_map)+ geom_bar() + coord_flip()
    }

    return(p)
}

#' @title get_CAG_by_community
#' @description
#' Return the CAG included in each community as a list
#' @param community_table : Community table with the species composition line
#' @param taxofile: path to the taxonomic format in the RDS format
#' @export
get_CAG_by_community <- function(community_table, taxofile)
    {
    taxo = generate_annotation(readRDS(taxofile))
    taxo = taxo[taxo$size > 499,]
    taxo = data.table(taxo)

    setkey(taxo,"annot")

    species_by_community = sapply(community_table['Community_composition',], strsplit, "-")
    get_CAG <- function(x){return(taxo[x, GU])}

    CAG_by_communities <- lapply(species_by_community, get_CAG)

    return(CAG_by_communities)
}


taxa_ordered_list <- function(p_tab)
{
    taxa_data = as.data.frame(apply(p_tab, 1, most_present_taxa), stringsAsFactors = FALSE)
    names(taxa_data)[1] = "composition"
    taxa_data["Community_name"] = row.names(taxa_data)
    nc =  dim(taxa_data)[1]

    taxa_data['index'] = 1:nc
    nl = nc
    line_length = 2
    for( i in 1:nc )
    {
                                        #print(i)
        vt = unlist(strsplit(taxa_data[i, "composition"],"-"))
        ns =length(vt)
                                        # break the large community on several lines
                                        #
        taxa_data[i, "composition"] = paste(vt[1:line_length], collapse= '-')
                                        # print(ns)
        if (ns > line_length)
        {
            n_lc = ns %/% line_length
            r_c = ns %% line_length

            inc = 1.0/(n_lc+2)
            if(n_lc >0 ){
                for(k in 1:(n_lc-1))
                {
                    nl = nl + 1
                                        # print(paste((line_length*k+1),(line_length*(k+1))))
                    taxa_data = rbind(taxa_data, data.frame(Community_name = "" ,composition = paste(vt[(line_length*k+1):(line_length*(k+1))], collapse='-'), index = i + inc))
                    inc= inc + 1.0/(n_lc+2)
                }
            }
            if(r_c > 0){
                nl = nl + 1
                                        #print(paste((line_length*(n_lc-1)+1),length(vt)))
                taxa_data = rbind(taxa_data, data.frame(Community_name = "" ,composition = paste(vt[((line_length*(n_lc))+1):length(vt)], collapse='-'), index = i + inc))

            }

        }
    }

    taxa_data = taxa_data[order(taxa_data$index),c(2,1)]
    #print.xtable(xtable(taxa_data), include.colnames = TRUE, include.rownames = FALSE )
    return(taxa_data)

}

most_present_taxa <- function(line){

    ng = length(line)
    nb_nn = sum(line > 0)
    p_sorted = sort(line*100, decreasing=TRUE)
    vect_p =  paste(names(p_sorted)[1:nb_nn], round(p_sorted[1:nb_nn], 2), rep("%",nb_nn),sep=" ")
     return(paste(vect_p, collapse = " - "))
}
